#ifndef P5_WASM_WASMER_GLOBAL
#define P5_WASM_WASMER_GLOBAL 1

#include "p5_wasm_wasmer.h"

typedef struct {
    wasm_global_t* global;
    wasm_exporttype_t* export_type;

    pid_t pid;

    SV* instance_sv;
} global_export_holder_t;

typedef struct {
    wasm_global_t* global;
    wasm_globaltype_t* type;

    pid_t pid;
    SV* given;
} global_import_holder_t;

global_import_holder_t* new_global_import (pTHX_ SV* given) {
    global_import_holder_t* new;
    Newxz(new, 1, global_import_holder_t);

    *new = (global_import_holder_t) {
        .pid = getpid(),
        .given = newSVsv(given),
    };

    return new;
}

static inline void global_import_sv_initialize (pTHX_ SV* self_sv, wasm_store_t* store, wasm_globaltype_t* type) {
    global_import_holder_t* holder_p = svrv_to_ptr(aTHX_ self_sv);

    const wasm_valtype_t* type_p = wasm_globaltype_content(type);

    wasm_valkind_t kind = wasm_valtype_kind(type_p);

    //wasm_global_t* global;

    wasm_val_t val;

    switch (kind) {
        case WASM_I32:
            val = (wasm_val_t) WASM_I32_VAL(SvIV(holder_p->given));
            break;

        case WASM_I64:
            val = (wasm_val_t) WASM_I64_VAL(SvIV(holder_p->given));
            break;

        case WASM_F32:
            val = (wasm_val_t) WASM_F32_VAL(SvNV(holder_p->given));
            break;

        case WASM_F64:
            val = (wasm_val_t) WASM_F64_VAL(SvNV(holder_p->given));
            break;

        default:
            assert(0);
    }

    SvREFCNT_dec(holder_p->given);
    holder_p->given = NULL;

    holder_p->global = wasm_global_new(store, type, &val);
    holder_p->type = type;

/*
    const wasm_externtype_t* externtype = wasm_importtype_type(import_type);

    if (wasm_externtype_kind(externtype) != WASM_EXTERN_GLOBAL) {
        
    }
*/
}

static inline SV* global_import_sv_mutability_sv (pTHX_ SV* self_sv) {

}

// ----------------------------------------------------------------------

static inline SV* global_export_sv_name_sv (pTHX_ SV* self_sv) {
    global_export_holder_t* global_holder_p = svrv_to_ptr(aTHX_ self_sv);

    const wasm_name_t* name = wasm_exporttype_name(global_holder_p->export_type);

    return newSVpvn( name->data, name->size );
}

wasm_mutability_t _get_export_mutability (global_export_holder_t* global_holder_p) {
    const wasm_externtype_t* type = wasm_exporttype_type(global_holder_p->export_type);

    const wasm_globaltype_t* gtype = wasm_externtype_as_globaltype_const(type);

    return wasm_globaltype_mutability(gtype);
}

static inline SV* global_export_sv_mutability_sv (pTHX_ SV* self_sv) {
    global_export_holder_t* global_holder_p = svrv_to_ptr(aTHX_ self_sv);

    return newSVuv(_get_export_mutability(global_holder_p));
}

static inline SV* global_export_sv_get_sv (pTHX_ SV* self_sv) {
    global_export_holder_t* global_holder_p = svrv_to_ptr(aTHX_ self_sv);

    wasm_val_t val;

    wasm_global_get( global_holder_p->global, &val );

    SV* ret;

    switch (val.kind) {
        case WASM_I32:
            ret = newSViv(val.of.i32);
            break;

        case WASM_I64:
            ret = newSViv(val.of.i64);
            break;

        case WASM_F32:
            ret = newSVnv(val.of.f32);
            break;

        case WASM_F64:
            ret = newSVnv(val.of.f64);
            break;

        default:
            ret = NULL; // silence compiler warnings
            assert(0 && "bad global valtype");
    }

    return ret;
}

static inline void global_export_sv_set_sv (pTHX_ SV* self_sv, SV* newval) {
    global_export_holder_t* global_holder_p = svrv_to_ptr(aTHX_ self_sv);

    wasm_global_t* global = global_holder_p->global;

    wasm_val_t val;

    // Simpler just to fetch the value than to trek through
    // the export_type -> extern_type -> global_type business.
    wasm_global_get( global_holder_p->global, &val );

    switch (val.kind) {
        case WASM_I32:
            val = (wasm_val_t) WASM_I32_VAL(SvIV(newval));
            break;

        case WASM_I64:
            val = (wasm_val_t) WASM_I64_VAL(SvIV(newval));
            break;

        case WASM_F32:
            val = (wasm_val_t) WASM_F32_VAL(SvNV(newval));
            break;

        case WASM_F64:
            val = (wasm_val_t) WASM_F64_VAL(SvNV(newval));
            break;

        default:
            assert(0 && "bad global valtype");
    }

    wasm_global_set(global, &val);

    if (_WASMER_HAS_ERROR) {
        const wasm_name_t* name = wasm_exporttype_name(global_holder_p->export_type);
        _croak_if_wasmer_error("Failed to set global “%.*s”", (int) name->size, name->data);
    }
}

static inline void destroy_export_global_sv (pTHX_ SV* self_sv) {
    global_export_holder_t* global_holder_p = svrv_to_ptr(aTHX_ self_sv);

    warn_destruct_if_needed(self_sv, global_holder_p->pid);

    SvREFCNT_dec( global_holder_p->instance_sv );

    Safefree(global_holder_p);
}

#endif

#ifndef P5_WASM_WASMER_GLOBAL
#define P5_WASM_WASMER_GLOBAL 1

#include "p5_wasm_wasmer.h"

typedef struct {
    wasm_global_t* global;
    SV* creator_sv;
    pid_t pid;
} global_holder_t;


// ----------------------------------------------------------------------

SV* global_export_to_sv (pTHX_ SV* creator_sv, wasm_extern_t* export_p) {
    wasm_global_t* global = wasm_extern_as_global(export_p);

    global_holder_t* global_holder;
    Newx(global_holder, 1, global_holder_t);

    *global_holder = (global_holder_t) {
        .global = global,
        .creator_sv = creator_sv,
        .pid = getpid(),
    };

    SvREFCNT_inc(creator_sv);

    return ptr_to_svrv( aTHX_
        global_holder,
        gv_stashpv(GLOBAL_CLASS, FALSE)
    );
}

wasm_mutability_t _get_mutability (global_holder_t* global_holder_p) {

    own wasm_globaltype_t* gtype = wasm_global_type(global_holder_p->global);

    wasm_mutability_t ret = wasm_globaltype_mutability(gtype);

    wasm_globaltype_delete(gtype);

    return ret;
}

SV* global_sv_mutability_sv (pTHX_ SV* self_sv) {
    global_holder_t* holder_p = svrv_to_ptr(aTHX_ self_sv);

    return newSVuv(_get_mutability(holder_p));
}

static inline SV* _wasm_global_to_sv (pTHX_ wasm_global_t* global) {
    wasm_val_t val;

    wasm_global_get( global, &val );

    return ww_val2sv(aTHX_ &val);
}

static inline void _wasm_global_set_sv (pTHX_ wasm_global_t* global, SV* newval) {
    wasm_val_t val;

    // Simpler just to fetch the value than to trek through
    // the export_type -> extern_type -> global_type business.
    wasm_global_get( global, &val );

    val = grok_wasm_val(aTHX_ val.kind, newval);

    wasm_global_set(global, &val);
}

static inline void destroy_global_sv (pTHX_ SV* self_sv) {
    global_holder_t* global_holder_p = svrv_to_ptr(aTHX_ self_sv);

    warn_destruct_if_needed(self_sv, global_holder_p->pid);

    SvREFCNT_dec( global_holder_p->creator_sv );

    Safefree(global_holder_p);
}

// ----------------------------------------------------------------------

static inline SV* global_holder_get_sv (pTHX_ global_holder_t* holder_p) {
    return _wasm_global_to_sv(aTHX_ holder_p->global);
}

static inline void global_holder_set_sv (pTHX_ global_holder_t* holder_p, SV* newval) {
    wasm_global_t* global = holder_p->global;

    _wasm_global_set_sv(aTHX_ global, newval);

    if (_WASMER_HAS_ERROR) {
        const wasm_globaltype_t* gtype = wasm_global_type(global);
        const wasm_valtype_t* vtype = wasm_globaltype_content(gtype);

        const char* mutability_descr[2];
        mutability_descr[WASM_CONST] = "constant";
        mutability_descr[WASM_VAR] = "mutable";

        const char* kind_descr[4];
        kind_descr[WASM_I32] = "i32";
        kind_descr[WASM_I64] = "i64";
        kind_descr[WASM_F32] = "f32";
        kind_descr[WASM_F64] = "f64";

        _croak_if_wasmer_error(
            "Failed to set %s %s global to %" SVf,
            mutability_descr[ wasm_globaltype_mutability(gtype) ],
            kind_descr[ wasm_valtype_kind(vtype) ],
            newval
        );

        assert(0);
    }
}

#endif

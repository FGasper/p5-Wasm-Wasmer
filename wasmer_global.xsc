#ifndef P5_WASM_WASMER_GLOBAL
#define P5_WASM_WASMER_GLOBAL 1

#include "p5_wasm_wasmer.h"

typedef struct {
    wasm_global_t* global;
    wasm_exporttype_t* export_type;

    pid_t pid;

    SV* instance_sv;
} global_export_holder_t;

typedef struct {
    wasm_global_t* global;
    wasm_globaltype_t* type;
    wasm_importtype_t* import_type;

    pid_t pid;
    SV* given;
} global_import_holder_t;

typedef struct {
    wasm_global_t* global;
    SV* store_sv;
    pid_t pid;
} global_holder_t;

wasm_val_t grok_wasm_val (pTHX_ wasm_externkind_t kind, SV* given) {
    wasm_val_t ret;

    switch (kind) {
        case WASM_I32:
            ret = (wasm_val_t) WASM_I32_VAL( grok_i32( aTHX_ given ) );
            break;

        case WASM_I64:
            ret = (wasm_val_t) WASM_I64_VAL( grok_i64( aTHX_ given ) );
            break;

        case WASM_F32:
            ret = (wasm_val_t) WASM_F32_VAL( SvNV( aTHX_ given ) );
            break;

        case WASM_F64:
            ret = (wasm_val_t) WASM_F64_VAL( SvNV( aTHX_ given ) );
            break;

        default:
            ret = (wasm_val_t) WASM_I32_VAL(0); // silence compiler
            assert(0);
    }

    return ret;
}

// ----------------------------------------------------------------------

/*
global_import_holder_t* new_global_import (pTHX_ SV* given) {
    global_import_holder_t* new;
    Newxz(new, 1, global_import_holder_t);

    *new = (global_import_holder_t) {
        .pid = getpid(),
        .given = newSVsv(given),
    };

    return new;
}

void destroy_global_import(pTHX_ global_import_holder_t* holder) {
    // TODO: warn if needed

    if (holder->given) {
        SvREFCNT_dec(holder->given);
    }

    if (holder->global) {
        //wasm_global_delete(holder->global);
    }
}

static inline wasm_global_t* global_import_sv_initialize (pTHX_ SV* global_sv, wasm_importtype_t* import_type, wasm_store_t* store, const wasm_globaltype_t* type) {
    global_import_holder_t* holder_p = svrv_to_ptr(aTHX_ global_sv);

    const wasm_valtype_t* type_p = wasm_globaltype_content(type);

    wasm_val_t val;

    switch (wasm_valtype_kind(type_p)) {
        case WASM_I32:
            val = (wasm_val_t) WASM_I32_VAL(grok_i32(holder_p->given));
            break;

        case WASM_I64:
            val = (wasm_val_t) WASM_I64_VAL(grok_i64(holder_p->given));
            break;

        case WASM_F32:
            val = (wasm_val_t) WASM_F32_VAL(grok_f32(holder_p->given));
            break;

        case WASM_F64:
            val = (wasm_val_t) WASM_F64_VAL(grok_f64(holder_p->given));
            break;

        default:
            assert(0);
    }

    SvREFCNT_dec(holder_p->given);
    holder_p->given = NULL;

    holder_p->global = wasm_global_new(store, type, &val);
    if (!holder_p->global) {
        const wasm_name_t* module = wasm_importtype_module(import_type);
        const wasm_name_t* name = wasm_importtype_name(import_type);

        _croak_if_wasmer_error(
            "Failed to create global %.*s.%.*s",
            (int) module->size, module->data,
            (int) name->size, name->data
        );

        croak(
            "Failed to create global %.*s.%.*s, but no Wasmer error?!?",
            (int) module->size, module->data,
            (int) name->size, name->data
        );
    }

    holder_p->type = (wasm_globaltype_t*) type;
    holder_p->import_type = import_type;

    return holder_p->global;
}

static inline SV* global_import_sv_mutability_sv (pTHX_ SV* self_sv) {

}
*/

// ----------------------------------------------------------------------

SV* global_export_to_sv (pTHX_ SV* store_sv, wasm_extern_t* export_p) {
    wasm_global_t* global = wasm_extern_as_global(export_p);

    global_holder_t* global_holder;
    Newx(global_holder, 1, global_holder_t);

    *global_holder = (global_holder_t) {
        .global = global,
        .store_sv = store_sv,
        .pid = getpid(),
    };

    SvREFCNT_inc(store_sv);

    return ptr_to_svrv( aTHX_
        global_holder,
        gv_stashpv(GLOBAL_CLASS, FALSE)
    );
}

static inline SV* global_export_sv_name_sv (pTHX_ SV* self_sv) {
    global_export_holder_t* global_holder_p = svrv_to_ptr(aTHX_ self_sv);

    const wasm_name_t* name = wasm_exporttype_name(global_holder_p->export_type);

    return newSVpvn_flags( name->data, name->size, SVf_UTF8 );
}

wasm_mutability_t _get_export_mutability (global_export_holder_t* global_holder_p) {
    const wasm_externtype_t* type = wasm_exporttype_type(global_holder_p->export_type);

    const wasm_globaltype_t* gtype = wasm_externtype_as_globaltype_const(type);

    return wasm_globaltype_mutability(gtype);
}

static inline SV* global_export_sv_mutability_sv (pTHX_ SV* self_sv) {
    global_export_holder_t* global_holder_p = svrv_to_ptr(aTHX_ self_sv);

    return newSVuv(_get_export_mutability(global_holder_p));
}

static inline SV* _wasm_global_to_sv (pTHX_ wasm_global_t* global) {
    wasm_val_t val;

    wasm_global_get( global, &val );

    SV* ret;

    switch (val.kind) {
        case WASM_I32:
            ret = newSViv(val.of.i32);
            break;

        case WASM_I64:
            ret = newSViv(val.of.i64);
            break;

        case WASM_F32:
            ret = newSVnv(val.of.f32);
            break;

        case WASM_F64:
            ret = newSVnv(val.of.f64);
            break;

        default:
            ret = NULL; // silence compiler warnings
            assert(0 && "bad global valtype");
    }

    return ret;
}

static inline void _wasm_global_set_sv (pTHX_ wasm_global_t* global, SV* newval) {
    wasm_val_t val;

    // Simpler just to fetch the value than to trek through
    // the export_type -> extern_type -> global_type business.
    wasm_global_get( global, &val );

    switch (val.kind) {
        case WASM_I32:
            val = (wasm_val_t) WASM_I32_VAL(SvIV(newval));
            break;

        case WASM_I64:
            val = (wasm_val_t) WASM_I64_VAL(SvIV(newval));
            break;

        case WASM_F32:
            val = (wasm_val_t) WASM_F32_VAL(SvNV(newval));
            break;

        case WASM_F64:
            val = (wasm_val_t) WASM_F64_VAL(SvNV(newval));
            break;

        default:
            assert(0 && "bad global valtype");
    }

    wasm_global_set(global, &val);
}

static inline SV* global_export_sv_get_sv (pTHX_ SV* self_sv) {
    global_export_holder_t* global_holder_p = svrv_to_ptr(aTHX_ self_sv);

    return _wasm_global_to_sv(aTHX_ global_holder_p->global);
}

static inline SV* global_import_holder_get_sv (pTHX_ global_import_holder_t* global_holder_p) {
    return _wasm_global_to_sv(aTHX_ global_holder_p->global);
}

static inline void global_import_holder_set_sv (pTHX_ global_import_holder_t* global_holder_p, SV* newval) {
    wasm_global_t* global = global_holder_p->global;

    _wasm_global_set_sv(aTHX_ global, newval);

    if (_WASMER_HAS_ERROR) {
        const wasm_name_t* module = wasm_importtype_module(global_holder_p->import_type);
        const wasm_name_t* name = wasm_importtype_name(global_holder_p->import_type);
        _croak_if_wasmer_error(
            "Failed to set imported global %.*s.%.*s",
            (int) module->size, module->data,
            (int) name->size, name->data
        );

        assert(0);
    }
}

static inline void global_export_sv_set_sv (pTHX_ SV* self_sv, SV* newval) {
    global_export_holder_t* global_holder_p = svrv_to_ptr(aTHX_ self_sv);

    wasm_global_t* global = global_holder_p->global;

    _wasm_global_set_sv(aTHX_ global, newval);

    if (_WASMER_HAS_ERROR) {
        const wasm_name_t* name = wasm_exporttype_name(global_holder_p->export_type);
        _croak_if_wasmer_error("Failed to set exported global “%.*s”", (int) name->size, name->data);

        assert(0);
    }
}

static inline void destroy_global_sv (pTHX_ SV* self_sv) {
    global_holder_t* global_holder_p = svrv_to_ptr(aTHX_ self_sv);

    warn_destruct_if_needed(self_sv, global_holder_p->pid);

    SvREFCNT_dec( global_holder_p->store_sv );

    Safefree(global_holder_p);
}

// ----------------------------------------------------------------------

static inline SV* global_holder_get_sv (pTHX_ global_holder_t* holder_p) {
    return _wasm_global_to_sv(aTHX_ holder_p->global);
}

static inline void global_holder_set_sv (pTHX_ global_holder_t* holder_p, SV* newval) {
    wasm_global_t* global = holder_p->global;

    _wasm_global_set_sv(aTHX_ global, newval);

    if (_WASMER_HAS_ERROR) {
        const wasm_globaltype_t* gtype = wasm_global_type(global);
        const wasm_valtype_t* vtype = wasm_globaltype_content(gtype);

        const char* mutability_descr[2];
        mutability_descr[WASM_CONST] = "constant";
        mutability_descr[WASM_VAR] = "mutable";

        const char* kind_descr[4];
        kind_descr[WASM_I32] = "i32";
        kind_descr[WASM_I64] = "i64";
        kind_descr[WASM_F32] = "f32";
        kind_descr[WASM_F64] = "f64";

        _croak_if_wasmer_error(
            "Failed to set %s %s global to %" SVf,
            mutability_descr[ wasm_globaltype_mutability(gtype) ],
            kind_descr[ wasm_valtype_kind(vtype) ],
            newval
        );

        assert(0);
    }
}

#endif

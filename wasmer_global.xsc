#ifndef P5_WASM_WASMER_GLOBAL
#define P5_WASM_WASMER_GLOBAL 1

#include "p5_wasm_wasmer.h"

typedef struct {
    wasm_global_t* global;
    wasm_exporttype_t* export_type;

    pid_t pid;

    SV* instance_sv;
} global_export_holder_t;

typedef struct {
    wasm_global_t* global;
    SV* store_sv;
    pid_t pid;
} global_holder_t;


// ----------------------------------------------------------------------

SV* global_export_to_sv (pTHX_ SV* store_sv, wasm_extern_t* export_p) {
    wasm_global_t* global = wasm_extern_as_global(export_p);

    global_holder_t* global_holder;
    Newx(global_holder, 1, global_holder_t);

    *global_holder = (global_holder_t) {
        .global = global,
        .store_sv = store_sv,
        .pid = getpid(),
    };

    SvREFCNT_inc(store_sv);

    return ptr_to_svrv( aTHX_
        global_holder,
        gv_stashpv(GLOBAL_CLASS, FALSE)
    );
}

static inline SV* global_export_sv_name_sv (pTHX_ SV* self_sv) {
    global_export_holder_t* global_holder_p = svrv_to_ptr(aTHX_ self_sv);

    const wasm_name_t* name = wasm_exporttype_name(global_holder_p->export_type);

    return newSVpvn_flags( name->data, name->size, SVf_UTF8 );
}

wasm_mutability_t _get_mutability (global_holder_t* global_holder_p) {

    own wasm_globaltype_t* gtype = wasm_global_type(global_holder_p->global);

    wasm_mutability_t ret = wasm_globaltype_mutability(gtype);

    wasm_globaltype_delete(gtype);

    return ret;
}

SV* global_sv_mutability_sv (pTHX_ SV* self_sv) {
    global_export_holder_t* global_holder_p = svrv_to_ptr(aTHX_ self_sv);

    return newSVuv(_get_mutability(global_holder_p));
}

static inline SV* _wasm_global_to_sv (pTHX_ wasm_global_t* global) {
    wasm_val_t val;

    wasm_global_get( global, &val );

    return ww_val2sv(aTHX_ &val);
}

static inline void _wasm_global_set_sv (pTHX_ wasm_global_t* global, SV* newval) {
    wasm_val_t val;

    // Simpler just to fetch the value than to trek through
    // the export_type -> extern_type -> global_type business.
    wasm_global_get( global, &val );

    switch (val.kind) {
        case WASM_I32:
            val = (wasm_val_t) WASM_I32_VAL(SvIV(newval));
            break;

        case WASM_I64:
            val = (wasm_val_t) WASM_I64_VAL(SvIV(newval));
            break;

        case WASM_F32:
            val = (wasm_val_t) WASM_F32_VAL(SvNV(newval));
            break;

        case WASM_F64:
            val = (wasm_val_t) WASM_F64_VAL(SvNV(newval));
            break;

        default:
            assert(0 && "bad global valtype");
    }

    wasm_global_set(global, &val);
}

static inline SV* global_export_sv_get_sv (pTHX_ SV* self_sv) {
    global_export_holder_t* global_holder_p = svrv_to_ptr(aTHX_ self_sv);

    return _wasm_global_to_sv(aTHX_ global_holder_p->global);
}

static inline void global_export_sv_set_sv (pTHX_ SV* self_sv, SV* newval) {
    global_export_holder_t* global_holder_p = svrv_to_ptr(aTHX_ self_sv);

    wasm_global_t* global = global_holder_p->global;

    _wasm_global_set_sv(aTHX_ global, newval);

    if (_WASMER_HAS_ERROR) {
        const wasm_name_t* name = wasm_exporttype_name(global_holder_p->export_type);
        _croak_if_wasmer_error("Failed to set exported global “%.*s”", (int) name->size, name->data);

        assert(0);
    }
}

static inline void destroy_global_sv (pTHX_ SV* self_sv) {
    global_holder_t* global_holder_p = svrv_to_ptr(aTHX_ self_sv);

    warn_destruct_if_needed(self_sv, global_holder_p->pid);

    SvREFCNT_dec( global_holder_p->store_sv );

    Safefree(global_holder_p);
}

// ----------------------------------------------------------------------

static inline SV* global_holder_get_sv (pTHX_ global_holder_t* holder_p) {
    return _wasm_global_to_sv(aTHX_ holder_p->global);
}

static inline void global_holder_set_sv (pTHX_ global_holder_t* holder_p, SV* newval) {
    wasm_global_t* global = holder_p->global;

    _wasm_global_set_sv(aTHX_ global, newval);

    if (_WASMER_HAS_ERROR) {
        const wasm_globaltype_t* gtype = wasm_global_type(global);
        const wasm_valtype_t* vtype = wasm_globaltype_content(gtype);

        const char* mutability_descr[2];
        mutability_descr[WASM_CONST] = "constant";
        mutability_descr[WASM_VAR] = "mutable";

        const char* kind_descr[4];
        kind_descr[WASM_I32] = "i32";
        kind_descr[WASM_I64] = "i64";
        kind_descr[WASM_F32] = "f32";
        kind_descr[WASM_F64] = "f64";

        _croak_if_wasmer_error(
            "Failed to set %s %s global to %" SVf,
            mutability_descr[ wasm_globaltype_mutability(gtype) ],
            kind_descr[ wasm_valtype_kind(vtype) ],
            newval
        );

        assert(0);
    }
}

#endif

#ifndef P5_WASM_WASMER_FUNCTION
#define P5_WASM_WASMER_FUNCTION 1

#include <assert.h>

#include "p5_wasm_wasmer.h"
#include "wasmer_extern.xsc"
#include "wasmer_callback.xsc"

SV* function_to_sv (pTHX_ SV* creator_sv, wasm_extern_t* export_p) {
    return extern_to_sv(aTHX_ creator_sv, export_p, FUNCTION_CLASS);
}

#define xsh_new_heap_struct(var, type, literal) STMT_START { \
    type* var;              \
    Newx(var, 1, type);     \
                            \
    *var = (type) literal;  \
} STMT_END

wasm_func_t* function_from_coderef (pTHX_ wasm_store_t* store, CV* coderef, const wasm_externtype_t* externtype, const wasm_name_t* modname, const wasm_name_t* funcname) {
    const wasm_functype_t* functype = wasm_externtype_as_functype_const(externtype);
    const wasm_valtype_vec_t* params = wasm_functype_params(functype);
    const wasm_valtype_vec_t* results = wasm_functype_results(functype);

    callback_holder_t* callback_holder_p;
    Newx(callback_holder_p, 1, callback_holder_t);

    *callback_holder_p = (callback_holder_t) {
        .store = store,
        .coderef = coderef,
        .modname = *modname,
        .funcname = *funcname,

#if WASM_WASMER_MUST_STORE_PERL
        .aTHX = aTHX,
#endif
    };

    wasm_valtype_vec_copy(
        &callback_holder_p->results,
        results
    );

    own wasm_functype_t* host_func_type = wasm_functype_new(
        (wasm_valtype_vec_t *) params,
        (wasm_valtype_vec_t *) results
    );

    own wasm_func_t* host_func = wasm_func_new_with_env(
        store,
        host_func_type,
        host_func_callback,
        callback_holder_p,
        free_callback_holder
    );

    if (!host_func) {
        wasm_functype_delete(host_func_type);

        _croak_if_wasmer_error("Failed to create WASM function from CODE reference");
    }

    SvREFCNT_inc( (SV*) coderef );

    return host_func;
}

#endif

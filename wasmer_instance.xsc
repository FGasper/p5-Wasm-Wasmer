#ifndef P5_WASM_WASMER_INSTANCE
#define P5_WASM_WASMER_INSTANCE 1

#include "p5_wasm_wasmer.h"

#include "wasmer_module.xsc"

#include "wasmer_callback.xsc"

#define P5_WASM_WASMER_INSTANCE_CLASS "Wasm::Wasmer::Instance"

#define usize size_t

typedef struct {
    wasm_instance_t* instance;
    SV* module_sv;

    pid_t pid;

    SV* wasi_sv;
    bool wasi_started;

    wasm_extern_vec_t exports;
} instance_holder_t;

/* ---------------------------------------------------------------------- */

static wasm_func_t* _get_instance_function(pTHX_ instance_holder_t* instance_holder_p, const char* funcname, STRLEN funcname_len, wasm_exporttype_t** export_type_p) {
    module_holder_t* module_holder_p = svrv_to_ptr(aTHX_ instance_holder_p->module_sv);

    wasm_exporttype_vec_t* export_types = &module_holder_p->export_types;

    wasm_extern_vec_t* exports = &instance_holder_p->exports;

    for (unsigned i = 0; i<exports->size; i++) {
        if (wasm_extern_kind(exports->data[i]) != WASM_EXTERN_FUNC)
            continue;

        const wasm_name_t* name = wasm_exporttype_name(export_types->data[i]);

        if (funcname_len != name->size) continue;
        if (!memEQ(name->data, funcname, funcname_len)) continue;

        /* Yay! We found our function. */

        *export_type_p = export_types->data[i];
        return wasm_extern_as_func(exports->data[i]);
    }

    return NULL;
}

static inline HV* get_hv_from_sv_or_croak (pTHX_ SV* sv, const char* description) {
    if (!SvROK(sv) || SVt_PVHV != SvTYPE(SvRV(sv))) {
        croak("%s must be a HASH reference, not `%" SVf "`", description, sv);
    }

    return (HV *) SvRV(sv);
}

static CV* _get_import_coderef( pTHX_ HV* imports_hv, const wasm_name_t* modname, const wasm_name_t* funcname, bool is_needed ) {
    SV** ns_hr_p = hv_fetch(imports_hv, modname->data, modname->size, 0);
    if (!ns_hr_p) {
        if (is_needed) {
            croak("Required import namespace “%.*s” not given!", (int) modname->size, modname->data);
        }
        else {
            return NULL;
        }
    }

    if (!SvROK(*ns_hr_p) || SVt_PVHV != SvTYPE(SvRV(*ns_hr_p))) {
        if (is_needed) {
            croak("Import namespace “%.*s” must be a HASH reference, not `%" SVf "`!", (int) modname->size, modname->data, *ns_hr_p);
        }
        else {
            return NULL;
        }
    }

    HV* ns_hv = (HV*) SvRV(*ns_hr_p);
    SV** import_val_p = hv_fetch(ns_hv, funcname->data, funcname->size, 0);

    if (!import_val_p) {
        if (is_needed) {
            croak("Required import “%.*s.%.*s” not given!", (int) modname->size, modname->data, (int) funcname->size, funcname->data);
        }
        else {
            return NULL;
        }
    }

    if (!SvROK(*import_val_p) || SVt_PVCV != SvTYPE(SvRV(*import_val_p))) {
        if (is_needed) {
            croak("Import “%.*s.%.*s” must be a CODE reference, not `%" SVf "`!", (int) modname->size, modname->data, (int) funcname->size, funcname->data, *import_val_p);
        }
        else {
            return NULL;
        }
    }

    return (CV*) *import_val_p;
}

SV* instance_to_sv (pTHX_ wasm_instance_t* instance, SV* module_sv, const char* class) {
    instance_holder_t* instance_holder_p;

    Newx(instance_holder_p, 1, instance_holder_t);

    *instance_holder_p = (instance_holder_t) {
        .instance = instance,
        .pid = getpid(),
        .module_sv = module_sv,
        .wasi_started = false,
    };

    SvREFCNT_inc(module_sv);

    wasm_instance_exports(instance, &instance_holder_p->exports);

    if (NULL == class) class = P5_WASM_WASMER_INSTANCE_CLASS;

    return ptr_to_svrv(aTHX_ instance_holder_p, gv_stashpv(class, FALSE));
}

const wasm_extern_t* _get_host_import(const wasmer_named_extern_vec_t* host_imports, const wasm_name_t* modname, const wasm_name_t* name) {
    usize i = 0;

    for (; i < host_imports->size; i++) {
        wasmer_named_extern_t* cur = host_imports->data[i];

        const wasm_name_t* cur_modname = wasmer_named_extern_module(cur);
        if (cur_modname->size != modname->size) continue;
        if (!memEQ(cur_modname->data, modname->data, modname->size)) continue;

        const wasm_name_t* cur_name = wasmer_named_extern_name(cur);
        if (cur_name->size != name->size) continue;
        if (!memEQ(cur_name->data, name->data, name->size)) continue;

        return wasmer_named_extern_unwrap(cur);
    }

    return NULL;
}

SV* create_instance_sv (pTHX_ SV* class_sv, SV* module_sv, SV* imports_sv, wasmer_named_extern_vec_t* host_imports ) {
    const char* class = class_sv ? SvPVbyte_nolen(class_sv) : P5_WASM_WASMER_INSTANCE_CLASS;

    HV* imports_hv = NULL;

    if (imports_sv) {
        if (SvOK(imports_sv)) {
            imports_hv = get_hv_from_sv_or_croak( aTHX_ imports_sv, "Imports" );
        }
    }

    module_holder_t* module_holder_p = svrv_to_ptr(aTHX_ module_sv);

    own wasm_importtype_vec_t import_types;
    wasm_module_imports(module_holder_p->module, &import_types);

    SV* store_sv = module_holder_p->store_sv;
    store_holder_t* store_holder_p = svrv_to_ptr(aTHX_ store_sv);

    wasm_extern_t* externs[import_types.size];

    for (size_t i = 0; i < import_types.size; ++i) {
        const wasm_name_t* modname = wasm_importtype_module(import_types.data[i]);
        const wasm_name_t* name = wasm_importtype_name(import_types.data[i]);

        if (_DEBUG) {
            fprintf(stderr, "Import %zu: %.*s/%.*s\n", i, (int)modname->size, modname->data, (int)name->size, name->data);
        }

        const wasm_externtype_t* externtype = wasm_importtype_type(import_types.data[i]);

        switch (wasm_externtype_kind(externtype)) {
            case WASM_EXTERN_FUNC: {
                wasm_extern_t* cur_extern_p = NULL;

                CV* coderef = _get_import_coderef(aTHX_ imports_hv, modname, name, false);

                if (NULL == coderef) {
                    if (host_imports) {
                        cur_extern_p = (wasm_extern_t*) _get_host_import(host_imports, modname, name);
                    }

                    if (!cur_extern_p) {
                        _get_import_coderef(aTHX_ imports_hv, modname, name, true);
                        assert(0);
                    }
                }
                else {
                    const wasm_functype_t* functype = wasm_externtype_as_functype_const(externtype);
                    const wasm_valtype_vec_t* params = wasm_functype_params(functype);
                    const wasm_valtype_vec_t* results = wasm_functype_results(functype);

                    callback_holder_t* callback_holder_p;

                    Newx(callback_holder_p, 1, callback_holder_t);

                    callback_holder_p->store = store_holder_p->store;
    #if WASM_WASMER_MUST_STORE_PERL
                    callback_holder_p->aTHX = aTHX;
    #endif
                    callback_holder_p->coderef = coderef;
                    SvREFCNT_inc( (SV*) coderef );
                    callback_holder_p->modname = *modname;
                    callback_holder_p->funcname = *name;

                    wasm_valtype_vec_copy(
                        &callback_holder_p->results,
                        results
                    );

                    own wasm_functype_t* host_func_type = wasm_functype_new((wasm_valtype_vec_t *) params, (wasm_valtype_vec_t *) results);

                    own wasm_func_t* host_func = wasm_func_new_with_env(
                        store_holder_p->store,
                        host_func_type,
                        host_func_callback,
                        callback_holder_p,
                        free_callback_holder
                    );

                    wasm_functype_delete(host_func_type);

                    cur_extern_p = wasm_func_as_extern(host_func);
                }

                externs[i] = cur_extern_p;
            } break;

            default:
                croak("Unhandled import type: %d\n", wasm_externtype_kind(externtype));
                break;
        }
    }

    own wasm_extern_vec_t imports = WASM_ARRAY_VEC(externs);
    wasm_trap_t* traps = NULL;

    own wasm_instance_t* instance = wasm_instance_new(
        NULL, /* Ignored, per the documentation */
        module_holder_p->module,
        &imports,
        &traps
    );

    for (unsigned i=0; i<import_types.size; i++) {
        wasm_func_t* func = wasm_extern_as_func(externs[i]);
        wasm_func_delete(func);
    }

    wasm_importtype_vec_delete(&import_types);

    // TODO: cleaner
    assert(instance);

    return instance_to_sv(instance, module_sv, class);
}

void destroy_instance_sv (pTHX_ SV* self_sv) {
    instance_holder_t* instance_holder_p = svrv_to_ptr(aTHX_ self_sv);

    warn_destruct_if_needed(self_sv, instance_holder_p->pid);

    wasm_instance_delete(instance_holder_p->instance);
    wasm_extern_vec_delete(&instance_holder_p->exports);

    SvREFCNT_dec(instance_holder_p->module_sv);

    if (instance_holder_p->wasi_sv) {
        SvREFCNT_dec(instance_holder_p->wasi_sv);
    }

    Safefree(instance_holder_p);
}

#endif
